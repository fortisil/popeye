/**
 * Website content context builder
 * Discovers user documentation and brand assets to populate website templates
 * with project-specific content instead of generic placeholders
 */

import { promises as fs } from 'node:fs';
import path from 'node:path';
import {
  stripCodeFences,
  extractProductName,
  extractTagline,
  extractDescription,
  extractFeatures,
  extractPricing,
  extractPrimaryColor,
} from './doc-parser.js';
import type { WebsiteStrategyDocument, BrandAssetsContract } from '../types/website-strategy.js';

/**
 * Structured content context for website generation
 */
export interface WebsiteContentContext {
  productName: string;
  tagline?: string;
  description?: string;
  features: Array<{ title: string; description: string }>;
  pricing?: Array<{
    name: string;
    price: string;
    period?: string;
    description: string;
    features: string[];
    cta: string;
    featured?: boolean;
  }>;
  brand?: {
    primaryColor?: string;
    colorScheme?: Record<string, string>;
    logoPath?: string;
  };
  rawDocs: string;
  /** Website marketing strategy (generated by AI from product context) */
  strategy?: WebsiteStrategyDocument;
  /** Resolved brand assets contract for deterministic logo/favicon placement */
  brandAssets?: BrandAssetsContract;
}

/**
 * Resolve brand assets into a deterministic contract
 * Searches for logo/favicon in project directory, sets canonical output paths
 *
 * @param cwd - Directory to scan for brand assets
 * @param brandContext - Optional existing brand context from state
 * @returns Resolved brand assets contract
 */
export async function resolveBrandAssets(
  cwd: string,
  brandContext?: { logoPath?: string; primaryColor?: string }
): Promise<BrandAssetsContract> {
  const assets = await findBrandAssets(cwd);
  const logoPath = brandContext?.logoPath || assets.logoPath;
  const ext = logoPath ? path.extname(logoPath) : '.svg';

  return {
    logoPath,
    logoOutputPath: `public/brand/logo${ext}`,
    primaryColor: brandContext?.primaryColor,
  };
}

/** Patterns to match documentation files */
const DOC_PATTERNS = [
  /spec/i,
  /pricing/i,
  /color/i,
  /brand/i,
  /ui[\s_-]?spec/i,
  /^readme\.md$/i,
  /overview/i,
  /features/i,
  /product/i,
];

/** Directories to exclude from scanning */
const EXCLUDED_DIRS = [
  'node_modules',
  '.popeye',
  '.git',
  'dist',
  'build',
  '.next',
  '__pycache__',
  'venv',
  '.venv',
  'coverage',
];

/**
 * Discover project documentation files in a directory
 *
 * @param cwd - Directory to scan for documentation
 * @returns Array of absolute paths to discovered doc files
 */
export async function discoverProjectDocs(cwd: string): Promise<string[]> {
  const docs: string[] = [];

  try {
    const entries = await fs.readdir(cwd, { withFileTypes: true });

    for (const entry of entries) {
      if (entry.isDirectory() && EXCLUDED_DIRS.includes(entry.name)) {
        continue;
      }

      if (entry.isFile() && entry.name.endsWith('.md')) {
        const matches = DOC_PATTERNS.some((pattern) => pattern.test(entry.name));
        if (matches) {
          docs.push(path.join(cwd, entry.name));
        }
      }

      // Check one level of subdirectories (e.g., docs/)
      if (entry.isDirectory() && entry.name === 'docs') {
        try {
          const subEntries = await fs.readdir(path.join(cwd, entry.name), {
            withFileTypes: true,
          });
          for (const subEntry of subEntries) {
            if (subEntry.isFile() && subEntry.name.endsWith('.md')) {
              docs.push(path.join(cwd, entry.name, subEntry.name));
            }
          }
        } catch {
          // Skip unreadable directories
        }
      }
    }
  } catch {
    // Directory not accessible
  }

  // Sort: color/brand docs first (small but critical), then others
  // This ensures brand context isn't truncated by the maxLength cap
  docs.sort((a, b) => {
    const nameA = path.basename(a).toLowerCase();
    const nameB = path.basename(b).toLowerCase();
    const priorityA = /color|brand/.test(nameA) ? 0 : 1;
    const priorityB = /color|brand/.test(nameB) ? 0 : 1;
    return priorityA - priorityB;
  });

  return docs;
}

/**
 * Find brand assets (logo files) in a directory
 *
 * @param cwd - Directory to scan for brand assets
 * @returns Object with optional logoPath
 */
export async function findBrandAssets(
  cwd: string
): Promise<{ logoPath?: string }> {
  const logoExtensions = ['.png', '.svg', '.jpg', '.jpeg', '.webp'];

  try {
    const entries = await fs.readdir(cwd, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isFile()) continue;

      const lowerName = entry.name.toLowerCase();
      const hasLogoInName = lowerName.includes('logo');
      const hasValidExt = logoExtensions.some((ext) => lowerName.endsWith(ext));

      if (hasLogoInName && hasValidExt) {
        return { logoPath: path.join(cwd, entry.name) };
      }
    }
  } catch {
    // Directory not accessible
  }

  return {};
}

/**
 * Read and concatenate project documentation files
 *
 * @param docPaths - Array of absolute paths to doc files
 * @param maxLength - Maximum combined length (default 15000 chars)
 * @returns Combined documentation content with file headers
 */
export async function readProjectDocs(
  docPaths: string[],
  maxLength: number = 15000
): Promise<string> {
  const sections: string[] = [];
  let totalLength = 0;

  for (const docPath of docPaths) {
    if (totalLength >= maxLength) break;

    try {
      const content = await fs.readFile(docPath, 'utf-8');
      const fileName = path.basename(docPath);
      const header = `--- ${fileName} ---`;
      const remaining = maxLength - totalLength;
      const trimmedContent =
        content.length > remaining ? content.slice(0, remaining) + '...' : content;

      sections.push(`${header}\n${trimmedContent}`);
      totalLength += header.length + 1 + trimmedContent.length;
    } catch {
      // Skip unreadable files
    }
  }

  return sections.join('\n\n');
}

/**
 * Build a structured website content context from discovered docs
 *
 * @param cwd - Working directory to scan for docs
 * @param projectName - The project name (folder name fallback)
 * @param specification - Optional expanded specification text
 * @returns Structured content context for website templates
 */
export async function buildWebsiteContext(
  cwd: string,
  projectName: string,
  specification?: string
): Promise<WebsiteContentContext> {
  const docPaths = await discoverProjectDocs(cwd);
  const rawDocs = docPaths.length > 0 ? await readProjectDocs(docPaths) : '';
  const brandAssets = await findBrandAssets(cwd);

  // Strip markdown code fences that wrap entire doc files
  const cleanDocs = stripCodeFences(rawDocs);

  const context: WebsiteContentContext = {
    productName: extractProductName(cleanDocs, specification) || projectName,
    features: extractFeatures(cleanDocs, specification),
    rawDocs,
  };

  context.tagline = extractTagline(cleanDocs, context.productName);
  context.description = extractDescription(cleanDocs, specification);
  context.pricing = extractPricing(cleanDocs);

  // Extract brand info
  if (brandAssets.logoPath) {
    context.brand = { ...context.brand, logoPath: brandAssets.logoPath };
  }

  const primaryColor = extractPrimaryColor(cleanDocs);
  if (primaryColor) {
    context.brand = { ...context.brand, primaryColor };
  }

  return context;
}

